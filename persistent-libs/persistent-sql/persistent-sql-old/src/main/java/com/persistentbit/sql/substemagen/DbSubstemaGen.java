package com.persistentbit.sql.substemagen;

/**
 * Substema generator for existing database tables
 *
 * @author petermuys
 * @since 1/11/16
 */
public class DbSubstemaGen{
	//
	//
	//	private final Supplier<Connection>     connectionSupplier;
	//	private final RSubstema                baseSubstema;
	//
	//	private final SubstemaCompiler         substemaCompiler;
	//	private final AnnotationsUtils         atUtils;
	//	private final Function<String, String> mapColumnNameToSubstemaName;
	//	private final Function<String, String> mapTableNameToSubstemaName;
	//
	//	private final Function<String, String> mapSubstemaTableNameToDbName;
	//	private final Function<String, String> mapSubstemaColumnNameToDbName;
	//
	//	private PList<Pattern>                  excludeTablePatterns       = PList.empty();
	//	private PList<Pattern>                  includeTablePatterns       = PList.empty();
	//	private PList<Tuple2<Pattern, Pattern>> excludeTableColumnPatterns = PList.empty();
	//
	//	private PMap<String, String>                   substemaNameForTableName       = PMap.empty();
	//	private PList<Tuple3<Pattern, String, String>> substemaNameForTableColumnName = PList.empty();
	//	private PList<Tuple3<Pattern, Pattern, REnum>> mapEnums                       = PList.empty();
	//
	//	private String schema;
	//
	//	private PList<RValueClass> valueClasses = PList.empty();
	//
	//	public DbSubstemaGen(Supplier<Connection> connectionSupplier, RSubstema baseSubstema,
	//						 SubstemaCompiler substemaCompiler
	//	) {
	//		this.connectionSupplier = connectionSupplier;
	//		this.baseSubstema = baseSubstema;
	//		this.substemaCompiler = substemaCompiler;
	//		this.atUtils = new AnnotationsUtils(substemaCompiler);
	//
	//		this.mapColumnNameToSubstemaName = DbAnnotationsUtils
	//			.createDbNameToSubstemaNameConverter(
	//				baseSubstema.getPackageDef().getAnnotations(), DbAnnotationsUtils.NameType.column, atUtils);
	//		this.mapTableNameToSubstemaName = DbAnnotationsUtils
	//			.createDbNameToSubstemaNameConverter(
	//				baseSubstema.getPackageDef().getAnnotations(), DbAnnotationsUtils.NameType.table, atUtils);
	//		this.mapSubstemaTableNameToDbName = DbAnnotationsUtils
	//			.createSubstemaToDbNameConverter(
	//				baseSubstema.getPackageDef().getAnnotations(), DbAnnotationsUtils.NameType.table, atUtils);
	//		this.mapSubstemaColumnNameToDbName = DbAnnotationsUtils
	//			.createSubstemaToDbNameConverter(
	//				baseSubstema.getPackageDef().getAnnotations(), DbAnnotationsUtils.NameType.column, atUtils);
	//	}
	//
	//	public void setSchema(String schema) {
	//		this.schema = schema;
	//	}
	//
	//	/**
	//	 * Include tables to be generated based on the table name
	//	 *
	//	 * @param tablePattern Regular expression of table names to include
	//	 */
	//	public void includeTables(String tablePattern) {
	//		includeTablePatterns = includeTablePatterns.plus(Pattern.compile(tablePattern));
	//	}
	//
	//	/**
	//	 * Exclude tables from being generated by filtering on the table name
	//	 *
	//	 * @param tablePattern Regular expression of table names to exclude
	//	 */
	//	public void excludeTables(String tablePattern) {
	//		excludeTablePatterns = excludeTablePatterns.plus(Pattern.compile(tablePattern));
	//	}
	//
	//	/**
	//	 * Exclude table columns from being generated by filtering on the table name and column name
	//	 *
	//	 * @param tablePattern  Regular expression for tables names where this rule is valid
	//	 * @param columnPattern Regular expression of column names to exclude
	//	 */
	//	public void excludeColumns(String tablePattern, String columnPattern) {
	//		excludeTableColumnPatterns =
	//			excludeTableColumnPatterns.plus(Tuple2.of(Pattern.compile(tablePattern), Pattern.compile(columnPattern)));
	//	}
	//
	//	public void setTableSubstemaName(String tableName, String substemaName) {
	//		substemaNameForTableName = substemaNameForTableName.put(tableName, substemaName);
	//	}
	//
	//	public void setTableColumnSubstemaName(String tableNamePattern, String columnName, String substemaColumnName) {
	//		substemaNameForTableColumnName = substemaNameForTableColumnName
	//			.plus(Tuple3.of(Pattern.compile(tableNamePattern), columnName, substemaColumnName));
	//	}
	//
	//	public void setEnum(String tableNamePattern, String columnPatternName, String enumClassName) {
	//		mapEnums = mapEnums.plus(Tuple3.of(
	//			Pattern.compile(tableNamePattern),
	//			Pattern.compile(columnPatternName),
	//			getEnumByName(enumClassName)
	//		));
	//	}
	//
	//
	//	/**
	//	 * Load the definition of the tables<br>
	//	 * @return executed ok?
	//	 */
	//	public Result<OK> loadTables() {
	//		return Result.function().code(log -> {
	//			List<String> tableNames = new ArrayList<>();
	//			log.info("IMPORTING META DATA FROM DB");
	//			handlePreBuildAnnotations();
	//			try(Connection c = connectionSupplier.get()) {
	//				DatabaseMetaData md = c.getMetaData();
	//				ResultSet        rs = md.getTables(null, schema, "%", new String[]{"TABLE", "VIEW"});
	//				while(rs.next()) {
	//					String tableName = rs.getString("TABLE_NAME");
	//					log.info("Found table " + tableName);
	//					if(includeTablePatterns.isEmpty() == false) {
	//						//Filter on included
	//						if(includeTablePatterns.find(pattern -> pattern.matcher(tableName).matches())
	//							.isPresent() == false) {
	//							log.info("Skipping table " + tableName);
	//							continue;
	//						}
	//					}
	//					if(excludeTablePatterns.find(p -> p.matcher(tableName).matches()).isPresent() == false) {
	//						tableNames.add(tableName);
	//					}
	//					else {
	//						log.info("Skipping table " + tableName);
	//					}
	//				}
	//				rs.close();
	//				c.commit();
	//			} catch(SQLException e) {
	//				return Result.failure(e);
	//			}
	//			for(String name : tableNames) {
	//
	//				valueClasses = valueClasses.plus(generateSubstemaForTable(name));
	//			}
	//			handlePostBuildAnnotations();
	//			return OK.result;
	//		});
	//
	//	}
	//
	//	/**
	//	 * Execute the pre loadTables package annotations
	//	 */
	//	private void handlePreBuildAnnotations() {
	//		PList<RAnnotation> atList = baseSubstema.getPackageDef().getAnnotations();
	//
	//		atList.forEach(at -> {
	//			RClass cls = at.getName();
	//			if(cls.equals(DbAnnotationsUtils.rclassDbImportExcludeTables)) {
	//				String tableNamePattern = getStringProperty(at, "tableNamePattern");
	//				excludeTables(tableNamePattern);
	//			}
	//			else if(cls.equals(DbAnnotationsUtils.rclassDbImportIncludeTables)) {
	//				String tableNamePattern = getStringProperty(at, "tableNamePattern");
	//				includeTables(tableNamePattern);
	//			}
	//			else if(cls.equals(DbAnnotationsUtils.rclassDbImportExcludeColumns)) {
	//				String tableNamePattern  = getStringProperty(at, "tableNamePattern");
	//				String columnNamePattern = getStringProperty(at, "columnNamePattern");
	//				excludeColumns(tableNamePattern, columnNamePattern);
	//			}
	//			else if(cls.equals(DbAnnotationsUtils.rclassDbImportSetColumnSubstemaName)) {
	//				String tableNamePattern = getStringProperty(at, "tableNamePattern");
	//				String columnName       = getStringProperty(at, "columnName");
	//				String substemaName     = getStringProperty(at, "substemaName");
	//				setTableColumnSubstemaName(tableNamePattern, columnName, substemaName);
	//			}
	//			else if(cls.equals(DbAnnotationsUtils.rclassDbImportSetTableSubstemaName)) {
	//				String tableName    = getStringProperty(at, "tableName");
	//				String substemaName = getStringProperty(at, "substemaName");
	//				setTableSubstemaName(tableName, substemaName);
	//			}
	//			else if(cls.equals(DbAnnotationsUtils.rclassDbImportUseEnum)) {
	//				String tableNamePattern  = getStringProperty(at, "tableNamePattern");
	//				String columnNamePattern = getStringProperty(at, "columnNamePattern");
	//				String enumClassName     = getStringProperty(at, "enumClassName");
	//				setEnum(tableNamePattern, columnNamePattern, enumClassName);
	//			}
	//			else if(cls.equals(DbAnnotationsUtils.rclassSchema)) {
	//				schema = getStringProperty(at, "name");
	//			}
	//		});
	//	}
	//
	//	/**
	//	 * Execute the post loadTables package annotations
	//	 */
	//	private void handlePostBuildAnnotations() {
	//		PList<RAnnotation> atList = baseSubstema.getPackageDef().getAnnotations();
	//		atList.forEach(at -> {
	//			RClass cls = at.getName();
	//			if(cls.equals(DbAnnotationsUtils.rclassDbImportMergeEmbedded)) {
	//				String tableNamePattern  = getStringProperty(at, "tableNamePattern");
	//				String columnNamePattern = getStringProperty(at, "columnNamePattern");
	//				String className         = getStringProperty(at, "className");
	//				mergeEmbedded(tableNamePattern, columnNamePattern, new RClass(className));
	//			}
	//
	//		});
	//	}
	//
	//	/**
	//	 * Get a String property from an annotation.
	//	 *
	//	 * @param at           The Annotation
	//	 * @param propertyName The name of the String property
	//	 *
	//	 * @return The property value as String
	//	 *
	//	 * @throws PersistSqlException When the property is not defined.
	//	 */
	//	private String getStringProperty(RAnnotation at, String propertyName) {
	//		Optional<String> optResult = atUtils.getStringProperty(at, propertyName);
	//		return optResult.orElseThrow(() ->
	//										 new PersistSqlException(
	//											 "Expecting " + propertyName + " in " + at.getName()
	//												 .getFullName() + " annotation")
	//		);
	//	}
	//
	//	private REnum getEnumByName(String className) {
	//
	//		return findEnumClass(new RClass(className)).orElseThrow(
	//			() -> new PersistSqlException("Can't find enum " + className)
	//		);
	//	}
	//
	//
	//	private RValueClass generateSubstemaForTable(String tableName) {
	//		return Log.function(tableName).code(log -> {
	//			PList<Pattern> columnExcludesForTable = excludeTableColumnPatterns
	//				.filter(t -> t._1.matcher(tableName).matches())
	//				.map(t -> t._2);
	//			PMap<String, String> columnNamesForTable = substemaNameForTableColumnName
	//				.filter(t -> t._1.matcher(tableName).matches())
	//				.map(t2 -> Tuple2.of(t2._2, t2._3)).groupByOneValue(t3 -> t3._1, t4 -> t4._2);
	//			PMap<Pattern, REnum> enumsForTable = mapEnums
	//				.filter(t -> t._1.matcher(tableName).matches())
	//				.map(t2 -> Tuple2.of(t2._2, t2._3)).groupByOneValue(t3 -> t3._1, t4 -> t4._2);
	//
	//			try(Connection c = connectionSupplier.get()) {
	//				DatabaseMetaData md = c.getMetaData();
	//
	//				//GET PRIMARY KEYS FOR TABLE
	//
	//				PMap<String, Integer> primKeys = PMap.empty();
	//				try(ResultSet rs = md.getPrimaryKeys(null, schema, tableName)) {
	//					while(rs.next()) {
	//						String name   = rs.getString("COLUMN_NAME");
	//						int    keySeq = rs.getInt("KEY_SEQ");
	//						primKeys = primKeys.put(name, keySeq);
	//					}
	//				}
	//
	//
	//				PList<RProperty> properties  = PList.empty();
	//				String           packageName = baseSubstema.getPackageName();
	//
	//				//GET COLUMNS
	//				try(ResultSet rs = md.getColumns(null, schema, tableName, "%")) {
	//					while(rs.next()) {
	//
	//						String name = rs.getString("COLUMN_NAME");
	//
	//						if(columnExcludesForTable.find(p -> p.matcher(name).matches()).isPresent()) {
	//							log.info("Skipping column " + tableName + "." + name);
	//							continue;
	//						}
	//
	//						//String  typeName        = rs.getString("TYPE_NAME"); //datasource dependent
	//						//int     columnSize      = rs.getInt("COLUMN_SIZE");
	//						//Integer decimalDigits   = (Integer) rs.getObject("DECIMAL_DIGITS");
	//						//String  defaultValue    = rs.getString("COLUMN_DEF");
	//						//int     ordinalPos      = rs.getInt("ORDINAL_POSITION");
	//						//int     charOctetLength = rs.getInt("CHAR_OCTET_LENGTH");
	//						//String  scopeTable      = rs.getString("SCOPE_TABLE");
	//						//Object  scopeDataType   = rs.getObject("SOURCE_DATA_TYPE");
	//						//Integer decimal_digits  = rs.getInt("DECIMAL_DIGITS");
	//
	//						int     data_type       = rs.getInt("DATA_TYPE"); //java.sql.Types
	//						boolean isNullable      = "YES".equals(rs.getString("IS_NULLABLE"));
	//						boolean isAutoIncrement = "YES".equals(rs.getString("IS_AUTOINCREMENT"));
	//						String  remarks         = rs.getString("REMARKS");
	//						SqlType sqlType;
	//						try {
	//							sqlType = SqlType.fromJavaSqlType(data_type);
	//
	//						} catch(Exception e) {
	//							throw new RuntimeException("Error getting sql type for column " + name, e);
	//						}
	//						boolean isKey = primKeys.getOpt(name).isPresent();
	//
	//						if(sqlType.getTypeSig().isPresent()) {
	//							RValueType valueType =
	//								new RValueType(sqlType.getTypeSig().get(), isNullable == false);
	//
	//							PList<RAnnotation> propAnnotations = PList.empty();
	//							if(isKey) {
	//								propAnnotations =
	//									propAnnotations.plus(new RAnnotation(DbAnnotationsUtils.rclassKey, PMap.empty()));
	//							}
	//							if(isAutoIncrement) {
	//								propAnnotations =
	//									propAnnotations.plus(new RAnnotation(DbAnnotationsUtils.rclassAutoGen, PMap.empty()));
	//							}
	//							String propName =
	//								columnNamesForTable.getOpt(name).orElse(mapColumnNameToSubstemaName.apply(name));
	//
	//
	//							if(mapSubstemaColumnNameToDbName.apply(propName).equals(name) == false) {
	//								PMap<String, RConst> nameValue = PMap.empty();
	//								nameValue = nameValue.put("name", new RConstString(name));
	//								propAnnotations =
	//									propAnnotations.plus(new RAnnotation(DbAnnotationsUtils.rclassColumn, nameValue));
	//							}
	//
	//							if(remarks != null && remarks.isEmpty() == false) {
	//								propAnnotations = propAnnotations
	//									.plus(new RAnnotation(SubstemaUtils.docRClass, PMap.<String, RConst>empty()
	//										.put("info", new RConstString(remarks))));
	//							}
	//
	//							if(valueType.getTypeSig().getName().equals(SubstemaUtils.stringRClass)) {
	//								for(Tuple2<Pattern, REnum> t : enumsForTable) {
	//									if(t._1.matcher(name).matches()) {
	//										valueType = valueType.withTypeSig(new RTypeSig(t._2.getName()));
	//										break;
	//									}
	//								}
	//							}
	//
	//							RProperty prop = new RProperty(
	//								propName, valueType, propAnnotations);
	//
	//							properties = properties.plus(prop);
	//						}
	//						else {
	//							//TODO find a better solution
	//							log.error("Can't convert " + sqlType + " in " + tableName + "." + name + ": SKIPPING COLUMN");
	//						}
	//					}
	//				}
	//
	//				PList<RAnnotation> annotations = PList.empty();
	//
	//				String substemaName =
	//					substemaNameForTableName.getOpt(tableName).orElse(mapTableNameToSubstemaName.apply(tableName));
	//
	//
	//				if(mapSubstemaTableNameToDbName.apply(substemaName).equals(tableName) == false) {
	//					PMap<String, RConst> nameValue = PMap.empty();
	//					nameValue = nameValue.put("name", new RConstString(tableName));
	//					annotations = annotations.plus(new RAnnotation(DbAnnotationsUtils.rclassTable, nameValue));
	//				}
	//				else {
	//					annotations = annotations.plus(new RAnnotation(DbAnnotationsUtils.rclassTable, PMap.empty()));
	//				}
	//				//Lets generate some documentation for the value class.
	//				String schemaAndTableName = schema != null ? schema + "." + tableName : tableName;
	//				annotations = annotations.plus(
	//					new RAnnotation(
	//						SubstemaUtils.docRClass,
	//						PMap.<String, RConst>empty().put("info", new RConstString(
	//							"\nThis immutable value class contains the data for a record in the table '" + schemaAndTableName + "'.<br>\n"
	//								+ "Generated from the database on " + LocalDateTime.now()
	//								.format(DateTimeFormatter.ISO_DATE_TIME) + "<br>\n"
	//						))
	//					)
	//				);
	//				log.info("Imported table " + tableName);
	//				c.commit();
	//				return new RValueClass(
	//					new RTypeSig(new RClass(packageName, substemaName)),
	//					properties,
	//					PList.empty(), //interfaceClasses
	//					annotations
	//				);
	//
	//			} catch(SQLException se) {
	//				RtSqlException.map(se);
	//				return null;
	//			}
	//
	//		});
	//	}
	//
	//	/**
	//	 * Merges the resulting value classes by
	//	 * removing all value classes that already exist in the baseSubstema.<br>
	//	 * The matching with the baseSubstema value classes are based on the resulting database table name.
	//	 */
	//	public void mergeWithBase() {
	//		PSet<String> baseDefinedTables =
	//			baseSubstema.getValueClasses().map(vc -> getTableName(vc).orElse(null)).filterNulls().pset();
	//		valueClasses = valueClasses.filter(vc -> baseDefinedTables.contains(getTableName(vc).orElse(null)) == false);
	//	}
	//
	//	/**
	//	 * Create a new  Substema that is the combination of the base substema with then new table values classes.<br>
	//	 *
	//	 * @param removeForNonExistingTable Set to true if existing table definitions that are not found in the db should be removed.
	//	 *
	//	 * @return the new Substema
	//	 */
	//	public RSubstema replaceBase(boolean removeForNonExistingTable) {
	//		PMap<String, RValueClass> generated = valueClasses.groupByOneValue(vc -> getTableName(vc).get());
	//		PList<RValueClass> newVcList = baseSubstema.getValueClasses().map(vc -> {
	//			String tableName = getTableName(vc).orElse(null);
	//			if(tableName == null) {
	//				return vc;
	//			}
	//			RValueClass newValueClass = generated.getOpt(tableName).orElse(null);
	//			if(newValueClass == null) {
	//				//We have an existing value class for a table we don't know about
	//				if(removeForNonExistingTable) {
	//					return null;
	//				}
	//				return vc;
	//			}
	//			return null;
	//		}).filterNulls().plusAll(valueClasses).plist();
	//		return baseSubstema.withValueClasses(newVcList);
	//	}
	//
	//
	//	/**
	//	 * Find the tablename for a value class<br>
	//	 *
	//	 * @param vc The value class
	//	 *
	//	 * @return empty when there is not @Table annotation on the value class, otherwise the db table name
	//	 */
	//	private Optional<String> getTableName(RValueClass vc) {
	//		RAnnotation tableAnnotation =
	//			vc.getAnnotations().find(at -> at.getName().getClassName().equals("Table")).orElse(null);
	//		if(tableAnnotation == null) {
	//			//If we don't have a @Table annotation, then it is not a table class.
	//			return Optional.empty();
	//		}
	//
	//		String result = atUtils.getStringProperty(tableAnnotation, "name").orElse(null);
	//		if(result != null) {
	//			//Table name is defined in the @Table annotation
	//			return Optional.of(result);
	//		}
	//		//Derive the table name from the value class name
	//		return Optional.of(mapSubstemaTableNameToDbName.apply(vc.getTypeSig().getName().getClassName()));
	//	}
	//
	//	/**
	//	 * Try to use an embeddable class in generated state classes
	//	 *
	//	 * @param tablePatternName  table names that need to be checked
	//	 * @param columnPatternName column names that need to be checked
	//	 * @param packageName       The packageName of the embedded class
	//	 * @param className         The className of the embedded class
	//	 */
	//	public void mergeEmbedded(String tablePatternName, String columnPatternName, String packageName, String className) {
	//		mergeEmbedded(tablePatternName, columnPatternName, new RClass(packageName, className));
	//	}
	//
	//	/**
	//	 * Try to use an embeddable class in generated state classes
	//	 *
	//	 * @param tablePatternName  table names that need to be checked
	//	 * @param columnPatternName column names that need to be checked
	//	 * @param embedCls          The embedded class
	//	 */
	//	public void mergeEmbedded(String tablePatternName, String columnPatternName, RClass embedCls) {
	//
	//		RClass cls = embedCls
	//			.withPackageName(embedCls.getPackageName() == null ? baseSubstema.getPackageName() : embedCls
	//				.getPackageName());
	//		//Let's first check if we have an import for the packageName...
	//		if(baseSubstema.getImports().find(i -> i.getPackageName().equals(cls.getPackageName())).isPresent() == false &&
	//			baseSubstema.getPackageName().equals(cls.getPackageName()) == false) {
	//
	//			throw new PersistSqlException("Can't merge " + cls.getFullName() + " into " +
	//											  baseSubstema.getPackageName() + " because the package is not imported.");
	//		}
	//
	//		RValueClass embeddable = findValueClass(cls)
	//			.orElseThrow(() -> new PersistSqlException("Can't find " + cls.getFullName()));
	//		mergeEmbedded(Pattern.compile(tablePatternName), Pattern.compile(columnPatternName), embeddable);
	//	}
	//
	//	private Optional<RValueClass> findValueClass(RClass cls) {
	//		RSubstema substema = substemaCompiler.compile(cls.getPackageName()).orElseThrow();
	//		return substema.getValueClasses().find(vc -> vc.getTypeSig().getName().equals(cls));
	//	}
	//
	//	private Optional<REnum> findEnumClass(RClass cls) {
	//		RSubstema substema = substemaCompiler.compile(cls.getPackageName()).orElseThrow();
	//		return substema.getEnums().find(e -> e.getName().equals(cls));
	//	}
	//
	//	/**
	//	 * Try to replace properties in de Values Classes generated from the db with an embedded Value Class
	//	 *
	//	 * @param tableNamePattern  Pattern for the table names that need to be checked.
	//	 * @param columnNamePattern Pattern for the column names that need to be checked.
	//	 * @param embeddable        The Value class that needs to be embedded
	//	 */
	//	private void mergeEmbedded(Pattern tableNamePattern, Pattern columnNamePattern, RValueClass embeddable) {
	//		valueClasses = valueClasses
	//			.map(gen -> {
	//				if(tableNamePattern.matcher(getTableName(gen).get()).matches()) {
	//					return mergeEmbedded(columnNamePattern, gen, embeddable);
	//				}
	//				return gen;
	//			});
	//	}
	//
	//	/**
	//	 * Try to replace properties in a Value Class with an embedded Value Class
	//	 *
	//	 * @param columnNamePattern Pattern for the column names that need to be checked.
	//	 * @param generated         The Value Class generated from the db
	//	 * @param embeddable        The Value class that needs to be embedded
	//	 *
	//	 * @return The new version of the Value class
	//	 */
	//	private RValueClass mergeEmbedded(Pattern columnNamePattern, RValueClass generated, RValueClass embeddable) {
	//
	//		PList<Tuple2<String, RValueType>> embCols = getFullColumnList(embeddable);
	//
	//		PList<Tuple2<String, RValueType>> genCols =
	//			getFullColumnList(generated)
	//				.filter(t -> columnNamePattern.matcher(t._1).matches());
	//
	//		PMap<String, PList<String>> found = PMap.empty();    //key = prefix name value = embedded columnName
	//		for(Tuple2<String, RValueType> genCol : genCols) {
	//			String genColName = genCol._1;
	//
	//			Tuple2<String, RValueType> matchingEmbCol = embCols.find(t -> genColName.endsWith(t._1)).orElse(null);
	//			if(matchingEmbCol != null) {
	//				String prefix = genColName.substring(0, genColName.length() - matchingEmbCol._1.length());
	//
	//				found = found.put(prefix, found.getOpt(prefix).orElse(PList.empty()).plus(matchingEmbCol._1));
	//			}
	//
	//		}
	//		//Filter found to get all the prefixes that have a complete embedded object
	//		found = found.filter(t -> t._2.containsAll(embCols.map(te -> te._1)));
	//
	//
	//		//For each prefix found.
	//		for(Tuple2<String, PList<String>> item : found) {
	//			String prefix = item._1;
	//			//Remove all involved properties for this prefix
	//			boolean areAllFieldNullable = true;
	//			for(String postFix : item._2) {
	//				String           fullName = prefix + postFix;
	//				PList<RProperty> allProps = generated.getProperties();
	//				RProperty matchingProperty = allProps.find(p -> getColumnNameForProperty(p).equals(fullName))
	//					.orElseThrow(() -> new PersistSqlException("Can't find " + fullName));
	//				if(matchingProperty.getDefaultValue().isPresent() || matchingProperty.getValueType().isRequired()) {
	//					areAllFieldNullable = false;
	//				}
	//				generated = generated.withProperties(allProps.filter(p -> p != matchingProperty));
	//			}
	//			//Now we need add the embedded object as a property
	//			PList<RAnnotation> annotations = PList.empty();
	//			String substemaPropertyName =
	//				prefix.isEmpty() ? "" : mapColumnNameToSubstemaName.apply(prefix.substring(0, prefix.length() - 1));
	//			if(substemaPropertyName.isEmpty()) {
	//				//If the prefix name is empty...
	//				substemaPropertyName = UString.firstLowerCase(embeddable.getTypeSig().getName().getClassName());
	//				RAnnotation colAt = new RAnnotation(DbAnnotationsUtils.rclassNoPrefix, PMap.empty());
	//				annotations = annotations.plus(colAt);
	//			}
	//			RProperty newProperty = new RProperty(
	//				substemaPropertyName,
	//				new RValueType(embeddable.getTypeSig(), areAllFieldNullable == false),
	//				annotations
	//			);
	//			generated = generated.withProperties(generated.getProperties().plus(newProperty));
	//		}
	//
	//		return generated;
	//	}
	//
	//	/**
	//	 * Flatten the properties in a value class
	//	 *
	//	 * @param vc The Value class
	//	 *
	//	 * @return A list with all column names and there value type
	//	 */
	//	private PList<Tuple2<String, RValueType>> getFullColumnList(RValueClass vc) {
	//		PList<Tuple2<String, RValueType>> res = PList.empty();
	//
	//		for(RProperty prop : vc.getProperties()) {
	//
	//			RClass propClass = prop.getValueType().getTypeSig().getName();
	//
	//			String columnNameForProp = getColumnNameForProperty(prop);
	//
	//			if(SubstemaUtils.isSubstemaClass(propClass)) {
	//				//Substema class
	//				if(SubstemaUtils.isCollectionClass(propClass)) {
	//					//ToDo
	//					throw new ToDo("Not yet implemented: collections for Db Substema code generator in " + vc
	//						.getTypeSig().getName().getFullName() + " " + prop.getName());
	//				}
	//				res = res.plus(Tuple2.of(columnNameForProp, prop.getValueType()));
	//			}
	//			else {
	//				//Must be an enum or valueClass
	//				REnum e = findEnumClass(prop.getValueType().getTypeSig().getName()).orElse(null);
	//				if(e != null) {
	//					res = res.plus(Tuple2.of(columnNameForProp, prop.getValueType()));
	//				}
	//				else {
	//					//Must be a valueClass
	//					res = res.plusAll(getFullColumnList(findValueClass(propClass).get())
	//										  .map(t -> t.with_1(columnNameForProp + "_" + t._1)));
	//				}
	//
	//			}
	//		}
	//		return res;
	//	}
	//
	//	private String getColumnNameForProperty(RProperty prop) {
	//		RAnnotation columnAnnotation =
	//			atUtils.getOneAnnotation(prop.getAnnotations(), DbAnnotationsUtils.rclassColumn).orElse(null);
	//		if(columnAnnotation != null) {
	//			String name = atUtils.getStringProperty(columnAnnotation, "name").orElse(null);
	//			if(name != null) {
	//				return name;
	//			}
	//		}
	//		return mapSubstemaColumnNameToDbName.apply(prop.getName());
	//	}
	//
	//	public PList<RValueClass> getValueClasses() {
	//		return valueClasses;
	//	}

}
